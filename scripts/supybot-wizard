#!/usr/bin/env python

import supybot

import fix

import os
import re
import sys
import sets
import pydoc
import pprint
import socket
import logging
import optparse
from itertools import imap

import log
import ansi
import registry
import conf
import utils
import Owner
import ircutils

import questions
from questions import output, yn, anything, something, expect, getpass

def getPlugins():
    filenames = []
    for dir in conf.supybot.directories.plugins():
        filenames.extend(os.listdir(dir))
    plugins = sets.Set([])
    for filename in filenames:
        if filename.endswith('.py') and filename[0].isupper():
            plugins.add(os.path.splitext(filename)[0])
    plugins.discard('Owner')
    plugins = list(plugins)
    plugins.sort()
    return plugins

def loadPlugin(name):
    try:
        module = Owner.loadPluginModule(name)
        if hasattr(module, 'Class'):
            return module
        else:
            output("""That plugin loaded fine, but didn't seem to be a real
            Supybot plugin; there was no Class variable to tell us what class
            to load when we load the plugin.  We'll skip over it for now, but
            you can always add it later.""")
            return None
    except Exception, e:
        output("""We encountered a bit of trouble trying to load plugin %r.
        Python told us %r.  We'll skip over it for now, you can always add it
        later.""" % (name, utils.exnToString(e)))
        return None

def describePlugin(module, showUsage):
    if module.__doc__:
        output(module.__doc__, unformatted=False)
    elif hasattr(module.Class, '__doc__'):
        output(module.Class.__doc__, unformatted=False)
    else:
        output("""Unfortunately, this plugin doesn't seem to have any
        documentation.  Sorry about that.""")
    if showUsage:
        if hasattr(module, 'example'):
            if yn('This plugin has a usage example.  '
                  'Would you like to see it?', default=False):
                pydoc.pager(module.example)
        else:
            output("""This plugin has no usage example.""")
    
def configurePlugin(module, advanced):
    if hasattr(module, 'configure'):
        output("""Beginning configuration for %s..."""%module.Class.__name__)
        module.configure(advanced)
        print # Blank line :)
        output("""Done!""")
    else:
        Owner.registerPlugin(module, currentValue=True)

def clearLoadedPlugins(plugins):
    for plugin, group in conf.supybot.plugins.children.iteritems():
        if plugin in plugins and group():
            plugins.remove(plugin)

_windowsVarRe = re.compile(r'%(\w+)%')
def getDirectoryName(default):
    done = False
    while not done:
        dir = something('What directory do you want to use?',
                       default=os.path.join(os.curdir, default))
        dir = os.path.expanduser(dir)
        dir = _windowsVarRe.sub(r'$\1', dir)
        dir = os.path.expandvars(dir)
        dir = os.path.abspath(dir)
        try:
            os.makedirs(dir)
            done = True
        except OSError, e:
            if e.args[0] != 17: # File exists.
                output("""Sorry, I couldn't make that directory for some
                reason.  The Operating System told me %s.  You're going to
                have to pick someplace else.""" % e)
            else:
                done = True
    return os.path.expandvars(os.path.expanduser(dir))

def main():
    conf.supybot.log.minimumPriority.setValue('CRITICAL')
    parser = optparse.OptionParser(usage='Usage: %prog [options]',
                                   version='Supybot %s' % conf.version)
    (options, args) = parser.parse_args()
    
    output("""This is a wizard to help you start running supybot.  What it
    will do is create a single Python file whose effect will be that of
    starting an IRC bot with the options you select here.  So hold on tight
    and be ready to be interrogated :)""")

    output("""First of all, we can bold the questions you're asked so you can
    easily distinguish the mostly useless blather (like this) from the
    questions that you actually have to answer.""")
    if yn('Would you like to try this bolding?', default=True):
        questions.useColor = True
        if not yn('Do you see this in bold?'):
            output("""Sorry, it looks like your terminal isn't ANSI compliant.
            Try again some other day, on some other terminal :)""")
            questions.useColor = False
        else:
            output("""Great!""")

    ###
    # Preliminary questions.
    ###
    output("""We've got some preliminary things to get out of the way before
    we can really start asking you questions that directly relate to what your
    bot is going to be like.""")

    # Advanced?
    output("""We want to know if you consider yourself an advanced Supybot
    user because some questions are just utterly boring and useless for new
    users.  Others might not make sense unless you've used Supybot for some
    time.""")
    advanced = yn('Are you an advanced Supybot user?', default=False)

    ### Directories.
    output("""Now we've got to ask you some questions about where some of
    your directories are (or, perhaps, will be :)).  If you're running this
    wizard from the directory you'll actually be starting your bot from and
    don't mind creating some directories in the current directory, then just
    don't give answers to these questions and we'll create the directories we
    need right here in this directory.""")

    # conf.supybot.directories.log
    output("""Your bot will need to put his logs somewhere.  Do you have any
    specific place you'd like them?  If not, just press enter and we'll make
    a directory named "logs" right here.""")
    conf.supybot.directories.log.setValue(getDirectoryName('logs'))

    # conf.supybot.directories.data
    output("""Your bot will need to put various data somewhere.  Things like
    databases, downloaded files, etc.  Do you have any specific place you'd
    like the bot to put these things?  If not, just press enter and we'll make
    a directory named "data" right here.""")
    conf.supybot.directories.data.setValue(getDirectoryName('data'))

    # conf.supybot.directories.conf
    output("""Your bot must know where to find his configuration files.  It'll
    probably only make one or two, but it's gotta have some place to put them.
    Where should that place be?  If you don't care, just press enter and we'll
    make a directory right here named "conf" where it'll store his stuff. """)
    conf.supybot.directories.conf.setValue(getDirectoryName('conf'))

    output("Good!  We're done with the directory stuff.")

    # pluginDirs
    output("""Your bot will also need to know where to find his plugins at.
    Of course, he already knows where the plugins that he came with are, but
    your own personal plugins that you write for will probably be somewhere
    else.  Where do you plan to put those plugins?  If you don't know, just
    press enter and we'll put a "plugins" directory right here that you can
    stick your own personal plugins in.""")
    pluginDirs = conf.supybot.directories.plugins()
    pluginDir = getDirectoryName('plugins')
    if pluginDir not in pluginDirs:
        pluginDirs.append(pluginDir)
    output("""Of course, you can have more than one plugin directory.""")
    while yn('Would you like to add another plugin directory?',
             default=False):
        pluginDir = getDirectoryName('plugins')
        if pluginDir not in pluginDirs:
            pluginDirs.append(pluginDir)
    conf.supybot.directories.plugins.setValue(pluginDirs)

    ###
    # Bot stuff
    ###
    output("""Now we're going to ask you things that actually relate to the
    bot you'll be running.""")

    # conf.supybot.server
    server = None
    while not server:
        serverString = something('What server would you like to connect to?')
        try:
            output("""Looking up %s...""" % serverString)
            ip = socket.gethostbyname(serverString)
        except:
            output("""Sorry, I couldn't find that server.  Perhaps you
            misspelled it?""")
            continue
        output("""Found %s (%s).""" % (serverString, ip))
        output("""IRC Servers almost always accept connections on port
        6667.  They can, however, accept connections anywhere their admin
        feels like he wants to accept connections from.""")
        if yn('Does this server require connection on a non-standard port?',
              default=False):
            port = 0
            while not port:
                port = something('What port is that?')
                try:
                    i = int(port)
                    if not (0 < i < 65536):
                        raise ValueError
                except ValueError:
                    output("""That's not a valid port.""")
                    port = 0
        else:
            port = 6667
        server = ':'.join(map(str, [serverString, port]))
    conf.supybot.server.setValue(server)

    # conf.supybot.nick
    nick = ''
    while not nick:
        nick = something('What nick would you like your bot to use?')
        if not ircutils.isNick(nick):
            output("""That's not a valid nick.  Go ahead and pick another.""")
            nick = ''
    conf.supybot.nick.setValue(nick)

    # conf.supybot.user
    user = ''
    output("""If you've ever done a /whois on a person, you know that IRC
    provides a way for users to show the world their full name.  What would
    you like your bot's full name to be?  If you don't care, just press
    enter and it'll be the same as your bot's nick.""")
    while not user:
        user = anything('What would you like your bot\'s full name to be?')
        if not user:
            user = nick
    conf.supybot.user.setValue(user)

    # conf.supybot.ident (if advanced)
    if advanced:
        ident = ''
        output("""IRC servers also allow you to set your ident, which they
        might need if they can't find your identd server.  What would you
        like your ident to be?  If you don't care, press enter and we'll
        use the same string as your bot's nick.""")
        while not ident:
            ident = anything('What would you like your bot\'s ident to be?')
            if not ident:
                ident = nick
    else:
        ident = nick
    conf.supybot.ident.setValue(ident)

    # conf.supybot.password
    output("""Some servers require a password to connect to them.  Most
    public servers don't.  If you try to connect to a server and for some
    reason it just won't work, it might be that you need to set a
    password.""")
    if yn('Do you want to set such a password?', default=False):
            conf.supybot.password.setValue(getpass())

    # conf.supybot.channels
    output("""Of course, having an IRC bot isn't the most useful thing in the
    world unless you can make that bot join some channels.""")
    if yn('Do you want your bot to join some channels when he connects?',
          default=True):
        channels = something('What channels?  Separate channels with '
                             'spaces.').split()
        while not all(ircutils.isChannel, channels):
            # FIXME: say which ones weren't channels.
            output("""Not all of those are valid IRC channels.  Be sure to
            prefix the channel with # (or +, or !, or &, but no one uses those
            channels, really).""")
            channels = something('What channels?').split()
    conf.supybot.channels.setValue(channels)

    ###
    # Plugins
    ###
    plugins = getPlugins()
    for s in ('Admin', 'User', 'Channel', 'Misc', 'Config'):
        configurePlugin(s, advanced)
    clearLoadedPlugins(plugins)

    # bulk
    addedBulk = False
    if advanced and yn('Would you like to add plugins en masse first?'):
        addedBulk = True
        output("""The available plugins are %s.  What plugins would you like
        to add?  If you've changed your mind and would rather not add plugins
        in bulk like this, just press enter and we'll move on to the individual
        plugin configuration.""" % utils.commaAndify(plugins))
        massPlugins = anything('Separate plugin names by spaces:')
        for name in re.split(r',?\s+', massPlugins):
            module = loadPlugin(name)
            if module is not None:
                configurePlugin(module, advanced)
                clearLoadedPlugins(plugins)

    # individual
    if yn('Would you like to look at plugins individually?'):
        output("""Next comes your oppurtunity to learn more about the plugins
        that are available and select some (or all!) of them to run in your
        bot.  Before you have to make a decision, of course, you'll be able to
        see a short description of the plugin and, if you choose, an example
        session with the plugin.  Let's begin.""")
        # until we get example strings again, this will default to false
        #showUsage =yn('Would you like the option of seeing usage examples?')
        showUsage = False
        name = expect('What plugin would you like to look at?', plugins)
        while name:
            module = loadPlugin(name)
            if module is not None:
                describePlugin(module, showUsage)
                if yn('Would you like to load this plugin?', default=True):
                    configurePlugin(module, advanced)
                    clearLoadedPlugins(plugins)
            if not yn('Would you like add another plugin?'):
                break
            name = expect('What plugin would you like to look at?', plugins)
    
    ###
    # Sundry
    ###
    output("""Although supybot offers a supybot-adduser.py script, with which
    you can add users to your bot's user database, it's *very* important that
    you have an owner user for you bot.""")
    if yn('Would you like to add an owner user for your bot?', default=True):
        import ircdb
        name = something('What should the owner\'s username be?')
        try:
            id = ircdb.users.getUserId(name)
            u = ircdb.users.getUser(id)
            if u.checkCapability('owner'):
                output("""That user already exists, and has owner capabilities
                already.  Perhaps you added it before? """)
                if yn('Do you want to remove its owner capability?',
                      default=False):
                    u.removeCapability('owner')
                    ircdb.users.setUser(id, u)
            else:
                output("""That user already exists, but doesn't have owner
                capabilities.""")
                if yn('Do you want to add to it owner capabilities?',
                      default=False):
                    u.addCapability('owner')
                    ircdb.users.setUser(id, u)
        except KeyError:
            password = getpass('What should the owner\'s password be?')
            (id, u) = ircdb.users.newUser()
            u.name = name
            u.setPassword(password)
            u.addCapability('owner')
            ircdb.users.setUser(id, u)

    output("""Of course, when you're in an IRC channel you can address the bot
    by its nick and it will respond, if you give it a valid command (it may or
    may not respond, depending on what your config variable replyWhenNotCommand
    is set to).  But your bot can also respond to a short "prefix character,"
    so instead of saying "bot: do this," you can say, "@do this" and achieve
    the same effect.  Of course, you don't *have* to have a prefix char, but
    if the bot ends up participating significantly in your channel, it'll ease
    things.""")
    if yn('Would you like to set the prefix char(s) for your bot?',
          default=True):
        output("""Enter any characters you want here, but be careful: they
        should be rare enough that people don't accidentally address the bot
        (simply because they'll probably be annoyed if they do address the bot
        on accident).  You can even have more than one.  I (jemfinch) am quite
        partial to @, but that's because I've been using it since my ocamlbot
        days.""")
        import callbacks
        while True:
            try:
                conf.supybot.prefixChars.setValue(
                                    something('What would you like your '
                                    'bot\'s prefix character(s) to be?',
                                    default='@'))
                break
            except registry.InvalidRegistryValue, reason:
                output(reason)
    else:
        conf.supybot.prefixChars.setValue('')

    # enablePipeSyntax
    output("""Supybot allows nested commands.  You've probably
    read about them in our website or documentation, and almost certainly have
    seen them in the plugin examples (if you chose to read them),  By default,
    they work with a syntax that looks something like Lisp with square
    brackets.  I.e., to call the command foo on the output of bar, you would
    use "foo [bar]".  Supybot is also capable of providing a pipe syntax
    similar to *nix pipes.  In addition to "foo [bar]", you could achieve the
    same effect with "bar | foo", which some people find more natural.  This
    syntax is disabled by default because so many people have pipes in their
    nicks, and we've found it to be somewhat frustrating to have to quote such
    nicks in commands.""")
    conf.supybot.pipeSyntax.setValue(yn('Would you like to enable the pipe '
                                 'syntax for nesting?', default=False))

    ###
    # logging variables.
    ###

    # conf.supybot.log.stdout
    output("""By default, your bot will log not only to files in the logs
    directory you gave it, but also to stdout.  We find this useful for
    debugging, and also just for the pretty output (it's colored!)""")
    conf.supybot.log.stdout.setValue(not yn('Would you like to turn off '
                                     'this logging to stdout?', default=False))
    if conf.supybot.log.stdout():
        # conf.something
        output("""Some terminals may not be able to display the pretty colors
        logged to stderr.  By default, though, we turn the colors off for
        Windows machines and leave it on for *nix machines.""")
        if os.name is not 'nt':
            conf.supybot.log.stdout.colorized.setValue(
                not yn('Would you like to turn this colorization off?',
                default=False))

    # conf.supybot.log.minimumPriority
    output("""Your bot can handle debug messages at several priorities,
    CRITICAL, in decreasing order of priority.  By
    default, your bot will log all of these priorities.  You can, however,
    specify that he only log messages above a certain priority level.  Of
    course, all error messages will still be logged.""")
    priority = something('What would you like the minimum priority to be?  '
                         'Just press enter to accept the default.',
                         default='INFO').lower()
    while priority not in ['debug', 'info', 'warning', 'error', 'critical']:
        output("""That's not a valid priority.  Valid priorities include
        'DEBUG', 'INFO', 'WARNING', 'ERROR', and 'CRITICAL'""")
        priority = something('What would you like the minimum priority to be?'
                             '  Just press enter to accept the default.',
                             default='INFO').lower()

    if advanced:
        output("""Here's some stuff you only get to choose if you're an
        advanced user :)""")

        # conf.supybot.reply.withNickPrefix
        output("""By defualt, the bot will respond to all commands with a
        Nick: <response> response.  That is, the user making the command will
        have their nick prefixed to the command.
        If supybot.reply.withNickPrefix is set to False, replies from the bot
        will not include this nick prefix.""")
        conf.supybot.reply.withNickPrefix.setValue(
            not yn('Would you like to turn off this nick prefix?',
            default=False))

        # conf.supybot.reply.whenAddressedByNick
        output("""By default, the bot will respond when addressed by its nick.
        That is, if the bot's nick is 'botnick', then 'botnick: foo' will call
        the foo command.  If replyWhenAddressedByNick is False, the bot will
        not respond to such messages.  Make sure you have a prefixChar set if
        you set this, otherwise people will only be able to communicate with
        the bot through private messages.""")
        conf.supybot.reply.whenAddressedByNick.setValue(
            not yn('Would you like to turn off the bot\'s replies to messages '
                   'prefixed with its nick?', default=False))

        # conf.supybot.showSimpleSyntax
        output("""By default, when the bot receives a message with invalid
        arguments, the bot returns the full help (syntax and description) of
        the command.  If showOnlySyntax is set to True, though, the bot will
        return just the syntax of the command.  Of course, the help will still
        be available via the help command.""")
        conf.supybot.showSimpleSyntax.setValue(
            yn('Would you like to show only the syntax of commands when '
              'they\'re given invalid arguments?', default=False))

        # conf.supybot.reply.whenNotCommand
        output("""By default, when people address your bot but don't give it
        a valid command, it'll respond with a message saying that they didn't
        give it a valid command.  When your channel grows more accustomed to
        the bot, they may prefer that it not do that, since any command you
        give the bot (at least within the included plugins) will respond with
        something, so invalid commands are still noticeable.  This decreases
        the channel traffic somewhat.""")
        conf.supybot.reply.whenNotCommand.setValue(
            not yn('Would you like to turn off the bot\'s replies when he\'s '
              'addressed but given a non-command?', default=False))

        # conf.supybot.reply.withPrivateNotice
        output("""When a user sends a command to the bot from within a
        channel, the bot, by default, also responds to that channel. In some
        rather busy channels this might be considered spam, especially if the
        command returns several lines in its result. In this case you may want
        to notice the user instead.""")
        conf.supybot.reply.withPrivateNotice.setValue(
            yn('Would you like the bot to notice replies to users in private '
              'when a command is executed in a channel?', default=False))

        # allowEval
        output("""Here in supybot-developer world, we really like Python.  In
        fact, we like it so much we just couldn't do without the ability to
        have our bots evaluate arbitrary Python code.  Of course, we are aware
        of the possible security hazards in allowing such a thing, but we're
        pretty sure our capability system is sound enough to do such a thing
        with some kind of security.  Nevertheless, by default we have these
        commands (eval and exec, both in the Owner plugin which is
        loaded by default) disabled by a config variable allowEval.  If you'd
        like to use either eval or exec, you'll have to make this variable
        True.  Unless you intend to hack on supybot a lot, we suggest against
        it -- it's just not worth the risk, and if you find something that you
        can't do via a command because the command you want doesn't exist, you
        should tell us and we'll implement the command (rather than make you
        allow eval).  But either way, here's your chance to enable it.""")
        allowEval = yn('Would you like to enable allowEval, possibly opening '
                       'you to a significant security risk?', default=False)

        # conf.supybot.throttleTime
        output("""In order to prevent flooding itself off the network,
        your bot by default will not send more than one message per second to
        the network.  This is, however, configurable.""")
        if yn('Would you like to change the minimum amount of time between '
              'messages your bot sends to the network?', default=False):
            while True:
                try:
                    conf.supybot.throttleTime.setValue(something(
                        'How long do you want your bot to wait between '
                        'sending messages to the server?  Floating '
                        'point values are accepted.'))
                    break
                except InvalidRegistryValue:
                    output("""That's not a valid time.  You'll need to give
                    a floating-point number.""")
        
    ###
    # This is close to the end.
    ###
    if not advanced:
        output("""There are a lot of options we didn't ask you about simply
        because we'd rather you get up and running and have time left to play
        around with your bot.  But come back and see us!  When you've played
        around with your bot enough to know what you like, what you don't like,
        what you'd like to change, then come back and run this script again
        and tell us you're an advanced user.  Some of those questions might be
        boring, but they'll really help you customize your bot :)""")

    ###
    # Writing the bot script.
    ###
    filename = reduce(os.path.join, [conf.installDir, 'src', 'template.py'])
    fd = file(filename)
    template = fd.read()
    fd.close()

    format = pprint.pformat
    template = template.replace('"%%allowEval%%"',
                                format(allowEval))
    template = template.replace('/usr/bin/env python',
                                os.path.normpath(sys.executable))

    filename = '%s-botscript.py' % nick
    fd = file(filename, 'w')
    fd.write(template)
    fd.close()

    if os.name == 'posix':
        os.chmod(filename, 0755)
    
    # Overwrite temporary minimum log priority
    conf.supybot.log.minimumPriority.setValue(priority)
    
    # Save the registry registry
    registry.close(conf.supybot, 'supybot.conf')
    
    # Done!
    output("""All done!  Your new bot script is %s.  If you're running a *nix,
    you can start your bot script with the command line "./%s".  If you're not
    running a *nix or similar machine, you'll just have to start it like you
    start all your other Python scripts.""" % (filename, filename))

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        # We may still be using bold text when exiting during a prompt
        if questions.useColor:
            import ansi
            print ansi.RESET
        print
        print
        output("""Well, it looks like you cancelled out of the wizard before
        it was done.  Unfortunately, I didn't get to write anything to file.
        Please run the wizard again to completion.""")
